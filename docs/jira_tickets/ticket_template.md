# [TICKET-ID]: [Component] Task Title

## Summary
Brief description of the task or feature to be implemented.

## Story Points: X
## Estimated Time: X hours/minutes
## Priority: Highest/High/Medium/Low
## Component: [Component Name]
## Phase: [Phase Number and Name]

---

## Prerequisites
- [ ] Previous dependencies completed
- [ ] Required tools/services available
- [ ] Understanding of relevant technical concepts

---

## Acceptance Criteria

### Must Have:
- [ ] Core functionality works as specified
- [ ] Performance meets defined targets
- [ ] Error handling implemented
- [ ] Integration points functional

### Performance Requirements:
- [ ] Specific performance metrics (response time, throughput, etc.)
- [ ] Resource usage limits (memory, CPU, etc.)
- [ ] Scalability targets

### Nice to Have:
- [ ] Additional features that would be beneficial
- [ ] Future-proofing considerations
- [ ] Enhanced user experience features

---

## Step-by-Step Implementation

### Step 1: [Component] Setup/Data Models

**Create `[file_path]`:**
```python
[Detailed implementation code for data models and structures]
```

### Step 2: [Core Implementation]

**Continue `[file_path]`:**
```python
[Main feature implementation with service methods]
```

### Step 3: Integration with Existing Systems

**Update `[file_path]`:**
```python
[Module exports and integration code]
```

### Step 4: [Additional Implementation Steps]

**[Additional files and configurations as needed]**

---

## Testing Strategy

### Unit Tests:
- [ ] Data model validation and serialization
- [ ] Core functionality with various inputs
- [ ] Error handling scenarios
- [ ] Configuration validation

### Integration Tests:
- [ ] Integration with dependent services
- [ ] End-to-end workflow validation
- [ ] Performance under load
- [ ] Concurrent operation handling

### [Feature-Specific Tests]:
- [ ] Domain-specific test scenarios
- [ ] Edge cases and boundary conditions
- [ ] Real-world usage patterns

---

## Validation Commands

Run these commands to verify implementation:

```bash
[Specific validation commands for the feature]
```

---

## Definition of Done
- [ ] All acceptance criteria met
- [ ] Unit tests pass with >90% coverage
- [ ] Integration tests pass
- [ ] Performance benchmarks met
- [ ] Error handling comprehensive
- [ ] Documentation updated
- [ ] Code review completed and approved
- [ ] Changes committed to git with meaningful message
- [ ] **Udemy tutorial created** (see Tutorial Creation section below)

---

## Dependencies
- **Depends On:** [Required tickets - e.g., TICKET-XXX, TICKET-YYY]
- **Blocks:** [Subsequent tickets - e.g., TICKET-ZZZ]

## Related Tickets
- [Related ticket 1]: [Description]
- [Related ticket 2]: [Description]

---

## Common Issues & Solutions

### Issue 1: [Common Problem]
**Error:** [Error message or symptom]
**Solution:** 
- [Step-by-step solution]
- [Additional troubleshooting steps]

### Issue 2: [Performance Issue]
**Error:** [Performance symptoms]
**Solution:**
- [Optimization approach]
- [Configuration adjustments]

---

## Learning Resources
- [Relevant documentation links]
- [Tutorial references]
- [Best practices guides]

---

## Notes for Reviewer
- [Specific areas to focus on during review]
- [Architectural decisions to validate]
- [Performance considerations]
- [Security implications]

## Git Commit Message Template
```
[type]: [brief description of changes]

- [Detailed change descriptions]
- [Implementation specifics]

Resolves: [TICKET-ID]
```

---

## ðŸŽ“ **Tutorial Creation Requirements**

**IMPORTANT**: After completing the implementation and deployment, create a Udemy tutorial explaining this feature. This means write the actual text the teacher should speak.

### Tutorial Specifications
- **Duration**: 15-30 minutes (depending on complexity)
- **Format**: Screen recording with detailed explanation
- **Target Audience**: Developers learning chatbot development
- **Skill Level**: [Beginner/Intermediate/Advanced]

### Tutorial Content Structure

#### 1. Introduction (2-3 minutes)
- [ ] Explain what was built and why it's important
- [ ] Show how this fits into the overall Archimedes architecture
- [ ] Preview what viewers will learn

#### 2. Theory & Architecture (3-5 minutes)
- [ ] Explain the underlying concepts and design decisions
- [ ] Discuss alternatives considered and why this approach was chosen
- [ ] Show architectural diagrams or visual aids

#### 3. Live Coding Demonstration (8-20 minutes)
- [ ] Step-by-step implementation walkthrough
- [ ] Explain each code decision and best practice
- [ ] Highlight potential pitfalls and how to avoid them
- [ ] Show testing and validation

#### 4. Integration & Testing (2-4 minutes)
- [ ] Demonstrate how this integrates with other components
- [ ] Show testing procedures and expected results
- [ ] Explain debugging approaches

#### 5. Wrap-up & Next Steps (1-2 minutes)
- [ ] Summarize key concepts and takeaways
- [ ] Preview how this connects to upcoming features

### Deliverables
- [ ] **Video Tutorial**: Complete screen recording with audio explanation
- [ ] **Code Repository**: Clean, commented code with examples
- [ ] **Written Guide**: Step-by-step written instructions
- [ ] **Exercise Materials**: Practice assignments for students
- [ ] **Troubleshooting Guide**: Common issues and solutions

### Tutorial Quality Checklist
- [ ] Audio is clear and professional
- [ ] Screen recording is high quality and easy to follow
- [ ] Code is well-commented and explained
- [ ] All steps are reproducible by students
- [ ] Includes real-world context and practical applications
- [ ] Addresses common questions and confusion points

### Post-Implementation Notes
*Complete this section after creating the tutorial*

#### What Worked Well:
- [Document effective teaching approaches]
- [Note concepts that were easy to explain]

#### Teaching Challenges:
- [Document difficult concepts to explain]
- [Note areas where students might struggle]

#### Improvements for Future Tutorials:
- [Lessons learned for better tutorial creation]
- [Techniques that enhanced understanding]