/**
 * API route for Pinecone document operations
 * POST /api/pinecone/documents - Upsert documents
 * GET /api/pinecone/documents - Search documents
 */

import { NextRequest, NextResponse } from 'next/server';
import { getPineconeService, PineconeDocument, PineconeDocType, SearchQuery } from '@/lib/pinecone/index';
import { z } from 'zod';

// Validation schemas
const UpsertDocumentSchema = z.object({
  id: z.string(),
  type: z.enum(['TICKET', 'COMMENT', 'TEMPLATE', 'VOICE_COMMAND', 'DOCUMENTATION']),
  metadata: z.object({
    teamId: z.string().optional(),
    userId: z.string().optional(),
    status: z.string().optional(),
    priority: z.string().optional(),
  }).passthrough(),
  content: z.object({
    title: z.string(),
    description: z.string(),
    fullText: z.string(),
  }),
});

const UpsertBatchSchema = z.object({
  documents: z.array(UpsertDocumentSchema),
});

const SearchSchema = z.object({
  query: z.string(),
  type: z.array(z.enum(['TICKET', 'COMMENT', 'TEMPLATE', 'VOICE_COMMAND', 'DOCUMENTATION'])).optional(),
  filters: z.object({
    teamId: z.string().optional(),
    userId: z.string().optional(),
    status: z.array(z.string()).optional(),
    dateRange: z.object({
      start: z.string().datetime().optional(),
      end: z.string().datetime().optional(),
    }).optional(),
  }).optional(),
  limit: z.number().min(1).max(100).default(10),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const pineconeService = getPineconeService();

    // Check if it's a batch operation
    if (body.documents && Array.isArray(body.documents)) {
      // Batch upsert
      const validated = UpsertBatchSchema.parse(body);
      
      // Add metadata
      const documents: PineconeDocument[] = validated.documents.map(doc => ({
        ...doc,
        type: doc.type as PineconeDocType,
        embedding: [], // Will be generated by service
        metadata: {
          ...doc.metadata,
          type: doc.type,
          createdAt: (doc.metadata.createdAt as number) || Date.now(),
        },
      }));

      await pineconeService.upsertBatch(documents);

      return NextResponse.json({
        success: true,
        message: `Successfully upserted ${documents.length} documents`,
        count: documents.length,
      });
    } else {
      // Single document upsert
      const validated = UpsertDocumentSchema.parse(body);
      
      const document: PineconeDocument = {
        ...validated,
        type: validated.type as PineconeDocType,
        embedding: [], // Will be generated by service
        metadata: {
          ...validated.metadata,
          type: validated.type,
          createdAt: (validated.metadata.createdAt as number) || Date.now(),
        },
      };

      await pineconeService.upsertDocument(document);

      return NextResponse.json({
        success: true,
        message: 'Document upserted successfully',
        id: document.id,
      });
    }
  } catch (error) {
    console.error('Error upserting document:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validation error', 
          details: error.errors 
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { 
        error: 'Failed to upsert document',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // Parse search parameters
    const params = {
      query: searchParams.get('query') || '',
      type: searchParams.get('type')?.split(',').filter(Boolean),
      filters: {
        teamId: searchParams.get('teamId') || undefined,
        userId: searchParams.get('userId') || undefined,
        status: searchParams.get('status')?.split(',').filter(Boolean),
        dateRange: {
          start: searchParams.get('startDate') || undefined,
          end: searchParams.get('endDate') || undefined,
        },
      },
      limit: parseInt(searchParams.get('limit') || '10'),
    };

    // Validate
    const validated = SearchSchema.parse(params);
    
    const pineconeService = getPineconeService();
    
    // Build search query
    const searchQuery: SearchQuery = {
      query: validated.query,
      type: validated.type as any,
      filters: {
        teamId: validated.filters?.teamId,
        userId: validated.filters?.userId,
        status: validated.filters?.status,
        dateRange: validated.filters?.dateRange ? {
          start: new Date(validated.filters.dateRange.start!),
          end: new Date(validated.filters.dateRange.end!),
        } : undefined,
      },
      limit: validated.limit,
    };

    const results = await pineconeService.search(searchQuery);

    return NextResponse.json({
      success: true,
      results,
      count: results.length,
      query: validated.query,
    });
  } catch (error) {
    console.error('Error searching documents:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: 'Validation error', 
          details: error.errors 
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { 
        error: 'Failed to search documents',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}